{"meta":{"title":"hulala1021's 博客","subtitle":"coder,steamer,sleeper....","description":"寻求简洁自然的编程方式。。。","author":"hulala1021","url":"http://doornote.net"},"pages":[{"title":"categories","date":"2016-07-13T02:26:38.000Z","updated":"2016-07-14T08:31:51.921Z","comments":false,"path":"categories/index.html","permalink":"http://doornote.net/categories/index.html","excerpt":"","text":""},{"title":"","date":"2016-07-12T10:01:47.928Z","updated":"2016-07-12T10:01:47.928Z","comments":false,"path":"tags/index.html","permalink":"http://doornote.net/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"利用Win32Api实现的一个简单的贪食蛇游戏","slug":"win32-gluttony-snake","date":"2016-07-14T08:21:11.000Z","updated":"2016-07-15T08:46:55.863Z","comments":true,"path":"2016/07/14/win32-gluttony-snake/","link":"","permalink":"http://doornote.net/2016/07/14/win32-gluttony-snake/","excerpt":"这是大学时期写的代码，当时看Windows程序设计(第5版)学习利用Win32Api编程，当时还没毕业，课程讲到Winform编程，便想通过对Win32Api的学习多了解Winform的一些比较底层实现。","text":"这是大学时期写的代码，当时看Windows程序设计(第5版)学习利用Win32Api编程，当时还没毕业，课程讲到Winform编程，便想通过对Win32Api的学习多了解Winform的一些比较底层实现。废话不多说，直接上代码：贪食蛇游戏++view raw123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304/****************************************************************** 贪食蛇 Preview 此版本贪吃蛇用蛇的方块是集合用的是数组 蛇移动是以Sleep()阻断进程实现的 故蛇移动看似较为卡顿，且数组插入数据效率较低， 故操作体验十分一般*******************************************************************/#include&lt;windows.h&gt;#include &lt;time.h&gt;#pragma comment(lib,\"winmm.lib\")#define LENGTH 40 //游戏场地的宽#define WIDTH 10 //组成蛇的的正方形的边长#define RANGE 50 //游戏场地与客户去之间间隔#define SNAKE_COLOR RGB(255,0,0) //蛇的颜色#define BK_COLOR RGB(204,232,207) //窗体背景色#define NO_SNAKE 0#define HAS_SNAKE 1#define STEP 2#define MAKECOOR(x) (x)*WIDTH //把flags数组的下标映射为坐标typedef struct{ int x; int y; int flag;} GRID;//蛇的结构LRESULT CALLBACK WndProc(HWND,UINT,WPARAM,LPARAM);void MakePartSnake(int,int,int,GRID *); //为蛇身增加或设置一个方块void MoveSnake(HWND); //移动蛇void MakeFood(GRID *food); //制造随机方块void initializer(); //初始化游戏void Manager();TCHAR szAppName[] = TEXT(\"Gluttony Snake\");int flags[LENGTH][LENGTH]; //游戏区域所有方块的状态标记RECT playground; //游戏场地GRID *snake = NULL; //蛇所在位置数组GRID *food = NULL; //食物对象static int MAX_LENGTH = 0;//默认蛇分配的最大长度（可变的）int snake_len = 0;int direct = 0;int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, int iCmdShow){ MSG msg; HWND hwnd; WNDCLASS wndclass; while(TRUE) { wndclass.cbClsExtra = 0; wndclass.cbWndExtra = 0; wndclass.hbrBackground=CreateSolidBrush(RGB(203,202,201)); wndclass.hIcon = LoadIcon(NULL,IDI_APPLICATION); wndclass.hCursor = LoadCursor(NULL,IDC_ARROW); wndclass.hInstance = hInstance; wndclass.lpfnWndProc = WndProc; wndclass.lpszMenuName = NULL; wndclass.lpszClassName = szAppName; wndclass.style = CS_VREDRAW | CS_HREDRAW; if(!RegisterClass(&amp;wndclass)) { MessageBox(NULL,TEXT(\"Register class failed!! Retry??\"),szAppName,0); return 0; } break; } hwnd = CreateWindow(szAppName, TEXT(\"Gluttony Snake Preview V1.0.1\"), WS_OVERLAPPEDWINDOW ^ WS_THICKFRAME ^ WS_MINIMIZEBOX ^ WS_MAXIMIZEBOX, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, NULL,NULL, hInstance, NULL); ShowWindow(hwnd,SW_NORMAL); UpdateWindow(hwnd); while(TRUE) { if(PeekMessage(&amp;msg,NULL,0,0,PM_REMOVE)) { if(msg.message == WM_QUIT) break; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); } else { MoveSnake(hwnd); } } return msg.wParam;}LRESULT CALLBACK WndProc(HWND hwnd,UINT message,WPARAM wParam,LPARAM lParam){ HDC hdc; PAINTSTRUCT ps; HBRUSH hBrush; switch(message) { case WM_DESTROY: PostQuitMessage(0); return 0; case WM_CREATE: //PlaySound(TEXT(\"HG.wav\"),NULL ,SND_ASYNC | SND_LOOP);//播放游戏音乐； initializer(); MoveWindow(hwnd, RANGE * 2, RANGE * 2, WIDTH * LENGTH + RANGE * 3, WIDTH * LENGTH + RANGE * 3, TRUE); return 0; case WM_KEYDOWN: switch(wParam) { case VK_LEFT: if(direct != VK_RIGHT) direct = VK_LEFT; break; case VK_RIGHT: if(direct != VK_LEFT) direct = VK_RIGHT; break; case VK_UP: if(direct != VK_DOWN) direct = VK_UP; break; case VK_DOWN: if(direct != VK_UP) direct = VK_DOWN; break; default: break; } return 0; case WM_PAINT: for(int i = 0; i != snake_len; ++i) { flags[(snake + i)-&gt;x][(snake + i)-&gt;y] = (snake + i)-&gt;flag; } hdc = BeginPaint(hwnd,&amp;ps); SetViewportOrgEx(hdc,RANGE/2,RANGE,NULL); hBrush = CreateSolidBrush(BK_COLOR); SelectObject(hdc,hBrush); Rectangle(hdc, playground.left, playground.top, playground.right, playground.bottom); DeleteObject(hBrush); hBrush = CreateSolidBrush(SNAKE_COLOR); SelectObject(hdc,hBrush); for(int i = 0; i != LENGTH;++i) { for(int j = 0; j != LENGTH;++j) { if(flags[i][j] == HAS_SNAKE) { Rectangle(hdc, MAKECOOR(i), MAKECOOR(j), MAKECOOR(i+1), MAKECOOR(j+1)); } } } DeleteObject(hBrush); EndPaint(hwnd,&amp;ps); } return DefWindowProc(hwnd,message,wParam,lParam);}//初始化游戏各个参数void initializer(){ if(snake != NULL) free(snake); if(food != NULL) free(food); snake_len = 3; //蛇的初始长度为3 direct = VK_RIGHT; //蛇的初始方向为向右 MAX_LENGTH = 100; //蛇默认最初分配最大长度为20 food = (GRID *)calloc(1,sizeof(GRID));//分配储存food的内存 snake = (GRID *)calloc(MAX_LENGTH,sizeof(GRID));//分配储存蛇的内存 /*************初始化游戏场地*******************/ playground.left = 0; playground.top = 0; playground.right = WIDTH * LENGTH; playground.bottom = WIDTH * LENGTH; /**************初始化游戏场地********************/ for(int i = 0 ;i &lt; LENGTH;++i) { for(int j = 0; j &lt; LENGTH;++j) { flags[i][j] = NO_SNAKE; } } for(int i = 0; i != snake_len;++i) { MakePartSnake(LENGTH / 2 + 2 - i,LENGTH / 2,HAS_SNAKE,(snake + i)); }///初始化蛇 MakeFood(food);///产生food}void MakePartSnake(int x,int y,int flag,GRID * snake){ snake-&gt;x = x; snake-&gt;y = y; snake-&gt;flag = flag;}//控制蛇的移动void MoveSnake(HWND hwnd){ Manager(); //把蛇的尾部去除（表现为蛇移动一格） flags[(snake + snake_len - 1)-&gt;x][(snake + snake_len - 1)-&gt;y] = NO_SNAKE; for(int i = snake_len - 1; i &gt; 0;--i) { (snake+i)-&gt;x = (snake + i -1)-&gt;x; (snake+i)-&gt;y = (snake + i -1)-&gt;y; } if(direct == VK_LEFT) { snake-&gt;x -= 1; } if(direct == VK_RIGHT) { snake-&gt;x += 1; } if(direct == VK_UP) { snake-&gt;y -= 1; } if(direct == VK_DOWN) { snake-&gt;y += 1; } InvalidateRect(hwnd,NULL,FALSE); Sleep(200);}//通过随机生成foodvoid MakeFood(GRID *food){ srand((unsigned) time(NULL)); food-&gt;x = rand() % LENGTH; food-&gt;y = rand() % LENGTH; food-&gt;flag = HAS_SNAKE; flags[food-&gt;x][food-&gt;y] = food-&gt;flag;}//游戏规则的映射及内存的处理void Manager(){ if(snake_len &gt;= MAX_LENGTH - 2) { MAX_LENGTH += STEP; snake = (GRID *)realloc(snake,MAX_LENGTH * sizeof(GRID)); }//若蛇的长度数组snake将超过所分配的内存就再次扩充分配 if(snake-&gt;x &lt; 0 || snake-&gt;x &gt;= LENGTH || snake-&gt;y &lt; 0 || snake-&gt;y &gt;= LENGTH) { MessageBox(NULL,TEXT(\"Game Over!!\"),szAppName,0); initializer(); return; }///判断蛇是否碰到边界 for(int i = 4;i &lt; snake_len;++i) { if(snake-&gt;x == (snake + i)-&gt;x &amp;&amp; snake-&gt;y == (snake + i)-&gt;y) { MessageBox(NULL,TEXT(\"Game Over!!\"),szAppName,0); initializer(); return; } }////判断蛇是否碰到自身 if(food-&gt;x == snake-&gt;x &amp;&amp; food-&gt;y == snake-&gt;y) { MakePartSnake( (snake + snake_len - 1)-&gt;x ,(snake + snake_len - 1)-&gt;y ,HAS_SNAKE ,snake + snake_len ); ++snake_len; MakeFood(food); }///判断蛇是否吃到food}代码在VS2010下编译运行(我使用的开发环境，VS其它版本也可以)，可见游戏界面如下：&ensp;以上代码未考虑通关情况，也就是如果水平够高蛇会把格子占满，然后Game over。注: 若在编译时报错：1error LNK2019: 无法解析的外部符号 _main，该符号在函数 ___tmainCRTStart 可按以下方法解决： 右键点击–&gt;项目，选择–&gt;属性，属性页 窗口弹出； 接着，点击连接器-&gt;系统，在右侧会看到“子系统”选项，将选项改为/subsystem:windows. 最后附上Github项目地址：gluttonysnake 本文永久链接： http://doornote.net/2016/07/14/win32-gluttony-snake/ ；欢迎转载。","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://doornote.net/categories/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://doornote.net/tags/C-C/"},{"name":"Win32Api","slug":"Win32Api","permalink":"http://doornote.net/tags/Win32Api/"},{"name":"Windows程序设计","slug":"Windows程序设计","permalink":"http://doornote.net/tags/Windows程序设计/"}]},{"title":"JAVA多线程编程——生产者消费者问题(1)","slug":"java-multithreading-1","date":"2016-07-13T07:54:25.000Z","updated":"2016-07-15T07:59:54.953Z","comments":true,"path":"2016/07/13/java-multithreading-1/","link":"","permalink":"http://doornote.net/2016/07/13/java-multithreading-1/","excerpt":"生产者消费者问题简述生产者消费者问题（英语：Producer-consumer problem），也称有限缓冲问题（英语：Bounded-buffer problem），是一个多线程同步问题的经典案例。该问题描述了两个共享固定大小缓冲区的线程——即所谓的“生产者”和“消费者”——在实际运行时会发生的问题。生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据; @Wikizh.wikipedia.org/wiki/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98","text":"生产者消费者问题简述生产者消费者问题（英语：Producer-consumer problem），也称有限缓冲问题（英语：Bounded-buffer problem），是一个多线程同步问题的经典案例。该问题描述了两个共享固定大小缓冲区的线程——即所谓的“生产者”和“消费者”——在实际运行时会发生的问题。生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据; @Wikizh.wikipedia.org/wiki/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98 &ensp;如下图所示：&ensp; 阻塞队列由以上模型可知缓冲区是建立起两个线程之间数据交互的桥梁；通常我们使用队列充当缓冲区，这里便引入阻塞队列的概念： 阻塞队列（BlockingQueue） 是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞 队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容 器里拿元素。 @引用来源www.infoq.com/cn/articles/java-blocking-queue 简单的泛型阻塞队列的实现阻塞队列的实现view raw123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.hulala.jt.demo1;import java.util.LinkedList;import java.util.Queue;/** * 队列的实现，支持线程间安全的offer poll操作 */public class BlockingQueue&lt;T&gt; { private Queue&lt;T&gt; queue; public BlockingQueue() { queue = new LinkedList&lt;T&gt;(); } /** * 向队列尾部添加一个对象 * * @param t * @return */ public synchronized boolean offer(T t) { boolean res = queue.offer(t); this.notify(); return res; } /** * 从队列头部取出一个对象 * * @return * @throws InterruptedException */ public synchronized T poll() { if (queue.size() == 0) { System.out.println(\"wait data\"); try { this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } return this.queue.poll(); } /** * 返回队列长度 * * @return */ public int size() { return this.queue.size(); }} 代码非常简单，就是通过对Queue对象进行二次封装，这里使用到了synchronized关键字：synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种 修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象； 修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象； 修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象； 修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。 @引用来源blog.csdn.net/luoweifu/article/details/46613015 生产者消费者模式初步实现下面来看看利用以上阻塞队列的生产者消费者模型的初步实现：App.javaview raw1234567891011121314151617181920212223242526272829package com.hulala.jt.demo1;public class App { public static void main(String[] args) { final BlockingQueue&lt;String&gt; queue = new BlockingQueue&lt;String&gt;(); //生产者线程 Thread cosumer = new Thread(new Runnable() { @Override public void run() { System.out.println(queue.poll()); } }); cosumer.start(); try { Thread.sleep(3000); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } //消费者线程 Thread producer = new Thread(new Runnable() { @Override public void run() { queue.offer(\"I am here\"); } }); producer.start(); }} 执行以上代码，会看到控制台输出：控制台输出：12wait dataI am here 代码执行流程如下： 在调用poll方法时,在代码块synchronized中会获得当前BlockingQueue实例的对象锁，若队列中无数据，则wait方法会使当前线程进入休眠等待状态，并释放对象锁； 在调用offer方法往队尾部添加数据之后，使用notify会时poll方法所在线程重新获取到当前BlockingQueue实例的对象锁，并继续执行wait方法后的代码； 以上测试代码即是一个最简单的生产者消费者模型，阻塞队列最常用场景就是在生产者消费者问题中。Github附上以上涉及代码的Github项目地址：producer-consumer &ensp; &ensp;之后相关生产者消费这问题的文章源码也都在该项目中。 本文永久链接： http://doornote.net/2016/07/13/java-multithreading-1/ ；欢迎转载。","categories":[{"name":"Java","slug":"Java","permalink":"http://doornote.net/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://doornote.net/tags/Java/"},{"name":"多线程编程","slug":"多线程编程","permalink":"http://doornote.net/tags/多线程编程/"},{"name":"生产者消费者问题","slug":"生产者消费者问题","permalink":"http://doornote.net/tags/生产者消费者问题/"}]}]}