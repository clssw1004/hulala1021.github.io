{"meta":{"title":"hulala1021's 博客","subtitle":"coder,steamer,sleeper....","description":"寻求简洁自然的编程方式。。。","author":"hulala1021","url":"http://doornote.net"},"pages":[{"title":"categories","date":"2016-07-13T02:26:38.000Z","updated":"2016-07-14T08:31:51.921Z","comments":false,"path":"categories/index.html","permalink":"http://doornote.net/categories/index.html","excerpt":"","text":""},{"title":"","date":"2016-07-12T10:01:47.928Z","updated":"2016-07-12T10:01:47.928Z","comments":false,"path":"tags/index.html","permalink":"http://doornote.net/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"程序员生产力工具推荐","slug":"productivity-tool-recommend","date":"2016-07-20T14:43:47.000Z","updated":"2016-07-20T14:44:50.413Z","comments":true,"path":"2016/07/20/productivity-tool-recommend/","link":"","permalink":"http://doornote.net/2016/07/20/productivity-tool-recommend/","excerpt":"","text":"本文持续更新 Markdown 写文档利器Markdown是一种轻量级标记语言，创始人为约翰·格鲁伯（John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML(或者HTML)文档”。[4]这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。 @引用来源zh.wikipedia.org/wiki/Markdown Markdown语法说明：https://zh.wikipedia.org/wiki/Markdown plantumlPlantUML是一个用来绘制UML图的Java类库。支持的UML图包括：时序图、用例图、类图、组件图、活动图。 example: 1234567@startumlAlice -&gt; Bob: Authentication RequestBob --&gt; Alice: Authentication ResponseAlice -&gt; Bob: Another authentication RequestAlice &lt;-- Bob: another authentication Response@enduml 12345678910@startumlstartif (Graphviz installed?) then (yes):process all\\ndiagrams;else (no):process only__sequence__ and __activity__ diagrams;endifstop@enduml plantuml语法说明：http://plantuml.com/sequence.html#Basic_examples 本文永久链接： http://doornote.net/2016/07/20/productivity-tool-recommend/ ；欢迎转载。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://doornote.net/categories/杂谈/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://doornote.net/tags/杂谈/"},{"name":"程序员","slug":"程序员","permalink":"http://doornote.net/tags/程序员/"}]},{"title":"JAVA多线程编程——生产者消费者模式(1)","slug":"java-multithreading-1","date":"2016-07-17T05:52:07.000Z","updated":"2016-07-19T09:26:01.941Z","comments":true,"path":"2016/07/17/java-multithreading-1/","link":"","permalink":"http://doornote.net/2016/07/17/java-multithreading-1/","excerpt":"生产者消费者问题简述生产者消费者问题（英语：Producer-consumer problem），也称有限缓冲问题（英语：Bounded-buffer problem），是一个多线程同步问题的经典案例。该问题描述了两个共享固定大小缓冲区的线程——即所谓的“生产者”和“消费者”——在实际运行时会发生的问题。生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据; @Wikizh.wikipedia.org/wiki/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98","text":"生产者消费者问题简述生产者消费者问题（英语：Producer-consumer problem），也称有限缓冲问题（英语：Bounded-buffer problem），是一个多线程同步问题的经典案例。该问题描述了两个共享固定大小缓冲区的线程——即所谓的“生产者”和“消费者”——在实际运行时会发生的问题。生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据; @Wikizh.wikipedia.org/wiki/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98 &ensp;如下图所示：&ensp; 阻塞队列由以上模型可知缓冲区是建立起两个线程之间数据交互的桥梁；通常我们使用队列充当缓冲区，这里便引入阻塞队列的概念： 阻塞队列（BlockingQueue） 是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞 队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容 器里拿元素。 @引用来源www.infoq.com/cn/articles/java-blocking-queue 简单的泛型阻塞队列的实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.hulala.jmt.pc1.pojo;import java.util.LinkedList;import java.util.Queue;/** * 队列的实现，支持线程间安全的offer poll操作 */public class BlockingQueue&lt;T&gt; &#123; private Queue&lt;T&gt; queue; public BlockingQueue() &#123; queue = new LinkedList&lt;T&gt;(); &#125; /** * 向队列尾部添加一个对象 * * @param t * @return */ public synchronized boolean offer(T t) &#123; boolean res = queue.offer(t); this.notify(); return res; &#125; /** * 从队列头部取出一个对象 * * @return * @throws InterruptedException */ public synchronized T poll() &#123; if (queue.size() == 0) &#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; return this.queue.poll(); &#125; /** * 返回队列长度 * * @return */ public int size() &#123; return this.queue.size(); &#125;&#125; 代码非常简单，就是通过对Queue对象进行二次封装，这里使用到了synchronized关键字：synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种 修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象； 修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象； 修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象； 修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。 @引用来源blog.csdn.net/luoweifu/article/details/46613015 生产者消费者模式初步实现下面来看看利用以上阻塞队列的生产者消费者模型的初步实现：12345678910111213141516171819202122232425262728293031package com.hulala.jmt.pc1;import com.hulala.jmt.pc1.pojo.BlockingQueue;public class App &#123; public static void main(String[] args) &#123; final BlockingQueue&lt;String&gt; queue = new BlockingQueue&lt;String&gt;(); //生产者线程 Thread cosumer = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(queue.poll()); &#125; &#125;); cosumer.start(); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; //消费者线程 Thread producer = new Thread(new Runnable() &#123; @Override public void run() &#123; queue.offer(\"I am here\"); &#125; &#125;); producer.start(); &#125;&#125; 执行以上代码，会看到控制台输出：12wait dataI am here 代码执行流程如下： 在调用poll方法时,在代码块synchronized中会获得当前BlockingQueue实例的对象锁，若队列中无数据，则wait方法会使当前线程进入休眠等待状态，并释放对象锁； 在调用offer方法往队尾部添加数据之后，使用notify会时poll方法所在线程重新获取到当前BlockingQueue实例的对象锁，并继续执行wait方法后的代码； 以上测试代码即是一个简单的生产者消费者模型，阻塞队列常用场景就是在生产者消费者问题中。 进阶显而易见的是，实际情况不会像以上例子那么简单，生产者消费者问题，是一个生产者持续产生数据到缓冲区、而消费者持续消耗缓冲区数据的过程；下面我们通过一个例子来说明；现以假设某个电子元件的生产流水线为例：&ensp; 通过上图可以很简单的看出这条流水线由4个流程组成，下面以面向对象的思想分析以上流程： 4个过程(打磨、抛光、焊接、质检)可抽象为4个操作 每个操作本身都是相对于前一操作来说是消费者，相对于后一操作来说是生产者； 每个操作实现不同（打磨、抛光、焊接、质检） 面向对象编程的思想要求我们找出对象的共同点在对其封装，对其不同点进行抽象。从以上分析我们已找到异同点，这便足以让我们开始写代码了； 首先 把电子元件抽象成一个Pojo:12345678910111213package com.hulala.jmt.pc1.pojo;public class ElectronicComponent &#123; public int code; public ElectronicComponent(int code) &#123; this.code = code; &#125; public void status(String opertion) &#123; System.out.println(\"编号：\" + code + \"正在执行\\\"\" + opertion +\"\\\"操作\"); &#125;&#125; 然后是抽象出每个操作：12345package com.hulala.jmt.pc1;public abstract class Operation &#123; protected abstract void operation(ElectronicComponent ec);&#125; 因为这边的操作是个抽象概念，并不涉及某个实际内容，所以只需声明函数签名，无需实现函数体，故使用抽象方法（在C++中为虚函数）。 现在已经抽象出不同点了，下面就要继续实现各个模块共同点，共同点由三个：入口、出口、传送带，抽象出来就是数据接收、数据产生、缓冲区(BlockingQueue)，可见这就是一个典型的生产者消费者模型：1234567891011121314151617181920212223242526272829package com.hulala.jmt.pc1;public abstract class Operation &#123; // 缓冲区 private BlockingQueue&lt;ElectronicComponent&gt; queue; public Operation() &#123; queue = new BlockingQueue&lt;ElectronicComponent&gt;(); &#125; /** * 数据接收 * * @param ec */ public void receive(ElectronicComponent ec) &#123; queue.offer(ec); &#125; /** * 数据传送 * * @param oper * @param ec */ public void send(Operation oper, ElectronicComponent ec) &#123; oper.receive(ec); &#125;&#125; 现在一个模块的骨架基本完成了，但是光这样还不够，上面说了：生产者消费者模式运行起来是个是个持续过程，所以我们要有一个线程，确保模块接收数据同时可以执行操作：12345678910111213141516public void doOperation(Operation oper) &#123; Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; ElectronicComponent ec = null; if ((ec = queue.poll()) != null) &#123; operation(ec); if (null != oper) send(oper, ec); &#125; &#125; &#125;); thread.setDaemon(false); thread.start();&#125; doOperation目的很明确，启动一个线程，循环从队列中取出数据，执行该模块的operation操作，执行完后传送给下一个模块；现在一个抽象的操作模块已经基本完成，可以具体实现流水线的4个操作了：12345678910111213141516171819202122232425262728293031DaMo.javapublic class DaMo extends Operation &#123; @Override protected void operation(ElectronicComponent ec) &#123; ec.status(\"打磨\"); &#125;&#125;PaoGuang.javapublic class PaoGuang extends Operation &#123; @Override protected void operation(ElectronicComponent ec) &#123; ec.status(\"抛光\"); &#125;&#125;HanJie.javapublic class HanJie extends Operation &#123; @Override protected void operation(ElectronicComponent ec) &#123; ec.status(\"焊接\"); &#125;&#125;ZhiJian.javapublic class ZhiJian extends Operation &#123; @Override protected void operation(ElectronicComponent ec) &#123; ec.status(\"质检\"); &#125;&#125; 写了那么多，终于可以测试一下看看了:12345678910111213141516171819202122232425//App2.javapackage com.hulala.jmt.pc1;import com.hulala.jmt.pc1.operation.DaMo;import com.hulala.jmt.pc1.operation.HanJie;import com.hulala.jmt.pc1.operation.Operation;import com.hulala.jmt.pc1.operation.PaoGuang;import com.hulala.jmt.pc1.operation.ZhiJian;import com.hulala.jmt.pc1.pojo.ElectronicComponent;public class App2 &#123; public static void main(String[] args) &#123; Operation damo = new DaMo(); Operation paoguang = new PaoGuang(); Operation hanjie = new HanJie(); Operation zhijian = new ZhiJian(); zhijian.doOperation(null); hanjie.doOperation(zhijian); paoguang.doOperation(hanjie); damo.doOperation(paoguang); for (int i = 0; i != 5; ++i) &#123; damo.receive(new ElectronicComponent(i)); &#125; &#125;&#125; 运行以上main方法，看控制台输出：12345678910111213141516171819编号：1正在执行&quot;打磨&quot;操作编号：2正在执行&quot;打磨&quot;操作编号：0正在执行&quot;抛光&quot;操作编号：3正在执行&quot;打磨&quot;操作编号：4正在执行&quot;打磨&quot;操作编号：0正在执行&quot;焊接&quot;操作编号：1正在执行&quot;抛光&quot;操作编号：0正在执行&quot;质检&quot;操作编号：2正在执行&quot;抛光&quot;操作编号：1正在执行&quot;焊接&quot;操作编号：3正在执行&quot;抛光&quot;操作编号：1正在执行&quot;质检&quot;操作编号：2正在执行&quot;焊接&quot;操作编号：4正在执行&quot;抛光&quot;操作编号：3正在执行&quot;焊接&quot;操作编号：2正在执行&quot;质检&quot;操作编号：4正在执行&quot;焊接&quot;操作编号：3正在执行&quot;质检&quot;操作编号：4正在执行&quot;质检&quot;操作 因为是多个线程异步执行，所以每次运行打出顺序可能会不一样。 总结到此为止，一个完整的流水线算是初步完成了，在上面分析及设计过程中： 封装对象的共同点，抽象对象的不同点是程序设计实现一个非常好的思路； 我们都用到了面向对象的三个基本特征：继承、封装、多态，类图关系如下： 生产者消费者模式是我们在多线程编程当中经常碰到的问题，掌握该模式足以让我们应付绝大多数多个线程之间数据交互的问题。 以上代码未考虑缓冲区溢出，省略了异常捕获，要真正用于生产环境这些都是要考略的。 Github完整代码的Github项目地址：producer-consumer&ensp; &ensp; 本文永久链接： http://doornote.net/2016/07/17/java-multithreading-1/ ；欢迎转载。","categories":[{"name":"Java","slug":"Java","permalink":"http://doornote.net/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://doornote.net/tags/Java/"},{"name":"多线程编程","slug":"多线程编程","permalink":"http://doornote.net/tags/多线程编程/"},{"name":"生产者消费者问题","slug":"生产者消费者问题","permalink":"http://doornote.net/tags/生产者消费者问题/"}]},{"title":"利用Win32Api实现的一个简单的贪食蛇游戏","slug":"win32-gluttony-snake","date":"2016-07-14T08:21:11.000Z","updated":"2016-07-18T12:09:28.917Z","comments":true,"path":"2016/07/14/win32-gluttony-snake/","link":"","permalink":"http://doornote.net/2016/07/14/win32-gluttony-snake/","excerpt":"这是大学时期写的代码，当时看Windows程序设计(第5版)学习利用Win32Api编程，当时还没毕业，课程讲到Winform编程，便想通过对Win32Api的学习多了解Winform的一些比较底层实现。","text":"这是大学时期写的代码，当时看Windows程序设计(第5版)学习利用Win32Api编程，当时还没毕业，课程讲到Winform编程，便想通过对Win32Api的学习多了解Winform的一些比较底层实现。废话不多说，直接上代码：贪食蛇游戏++view raw123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304/****************************************************************** 贪食蛇 Preview 此版本贪吃蛇用蛇的方块是集合用的是数组 蛇移动是以Sleep()阻断进程实现的 故蛇移动看似较为卡顿，且数组插入数据效率较低， 故操作体验十分一般*******************************************************************/#include&lt;windows.h&gt;#include &lt;time.h&gt;#pragma comment(lib,\"winmm.lib\")#define LENGTH 40 //游戏场地的宽#define WIDTH 10 //组成蛇的的正方形的边长#define RANGE 50 //游戏场地与客户去之间间隔#define SNAKE_COLOR RGB(255,0,0) //蛇的颜色#define BK_COLOR RGB(204,232,207) //窗体背景色#define NO_SNAKE 0#define HAS_SNAKE 1#define STEP 2#define MAKECOOR(x) (x)*WIDTH //把flags数组的下标映射为坐标typedef struct{ int x; int y; int flag;} GRID;//蛇的结构LRESULT CALLBACK WndProc(HWND,UINT,WPARAM,LPARAM);void MakePartSnake(int,int,int,GRID *); //为蛇身增加或设置一个方块void MoveSnake(HWND); //移动蛇void MakeFood(GRID *food); //制造随机方块void initializer(); //初始化游戏void Manager();TCHAR szAppName[] = TEXT(\"Gluttony Snake\");int flags[LENGTH][LENGTH]; //游戏区域所有方块的状态标记RECT playground; //游戏场地GRID *snake = NULL; //蛇所在位置数组GRID *food = NULL; //食物对象static int MAX_LENGTH = 0;//默认蛇分配的最大长度（可变的）int snake_len = 0;int direct = 0;int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, int iCmdShow){ MSG msg; HWND hwnd; WNDCLASS wndclass; while(TRUE) { wndclass.cbClsExtra = 0; wndclass.cbWndExtra = 0; wndclass.hbrBackground=CreateSolidBrush(RGB(203,202,201)); wndclass.hIcon = LoadIcon(NULL,IDI_APPLICATION); wndclass.hCursor = LoadCursor(NULL,IDC_ARROW); wndclass.hInstance = hInstance; wndclass.lpfnWndProc = WndProc; wndclass.lpszMenuName = NULL; wndclass.lpszClassName = szAppName; wndclass.style = CS_VREDRAW | CS_HREDRAW; if(!RegisterClass(&amp;wndclass)) { MessageBox(NULL,TEXT(\"Register class failed!! Retry??\"),szAppName,0); return 0; } break; } hwnd = CreateWindow(szAppName, TEXT(\"Gluttony Snake Preview V1.0.1\"), WS_OVERLAPPEDWINDOW ^ WS_THICKFRAME ^ WS_MINIMIZEBOX ^ WS_MAXIMIZEBOX, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, NULL,NULL, hInstance, NULL); ShowWindow(hwnd,SW_NORMAL); UpdateWindow(hwnd); while(TRUE) { if(PeekMessage(&amp;msg,NULL,0,0,PM_REMOVE)) { if(msg.message == WM_QUIT) break; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); } else { MoveSnake(hwnd); } } return msg.wParam;}LRESULT CALLBACK WndProc(HWND hwnd,UINT message,WPARAM wParam,LPARAM lParam){ HDC hdc; PAINTSTRUCT ps; HBRUSH hBrush; switch(message) { case WM_DESTROY: PostQuitMessage(0); return 0; case WM_CREATE: //PlaySound(TEXT(\"HG.wav\"),NULL ,SND_ASYNC | SND_LOOP);//播放游戏音乐； initializer(); MoveWindow(hwnd, RANGE * 2, RANGE * 2, WIDTH * LENGTH + RANGE * 3, WIDTH * LENGTH + RANGE * 3, TRUE); return 0; case WM_KEYDOWN: switch(wParam) { case VK_LEFT: if(direct != VK_RIGHT) direct = VK_LEFT; break; case VK_RIGHT: if(direct != VK_LEFT) direct = VK_RIGHT; break; case VK_UP: if(direct != VK_DOWN) direct = VK_UP; break; case VK_DOWN: if(direct != VK_UP) direct = VK_DOWN; break; default: break; } return 0; case WM_PAINT: for(int i = 0; i != snake_len; ++i) { flags[(snake + i)-&gt;x][(snake + i)-&gt;y] = (snake + i)-&gt;flag; } hdc = BeginPaint(hwnd,&amp;ps); SetViewportOrgEx(hdc,RANGE/2,RANGE,NULL); hBrush = CreateSolidBrush(BK_COLOR); SelectObject(hdc,hBrush); Rectangle(hdc, playground.left, playground.top, playground.right, playground.bottom); DeleteObject(hBrush); hBrush = CreateSolidBrush(SNAKE_COLOR); SelectObject(hdc,hBrush); for(int i = 0; i != LENGTH;++i) { for(int j = 0; j != LENGTH;++j) { if(flags[i][j] == HAS_SNAKE) { Rectangle(hdc, MAKECOOR(i), MAKECOOR(j), MAKECOOR(i+1), MAKECOOR(j+1)); } } } DeleteObject(hBrush); EndPaint(hwnd,&amp;ps); } return DefWindowProc(hwnd,message,wParam,lParam);}//初始化游戏各个参数void initializer(){ if(snake != NULL) free(snake); if(food != NULL) free(food); snake_len = 3; //蛇的初始长度为3 direct = VK_RIGHT; //蛇的初始方向为向右 MAX_LENGTH = 100; //蛇默认最初分配最大长度为20 food = (GRID *)calloc(1,sizeof(GRID));//分配储存food的内存 snake = (GRID *)calloc(MAX_LENGTH,sizeof(GRID));//分配储存蛇的内存 /*************初始化游戏场地*******************/ playground.left = 0; playground.top = 0; playground.right = WIDTH * LENGTH; playground.bottom = WIDTH * LENGTH; /**************初始化游戏场地********************/ for(int i = 0 ;i &lt; LENGTH;++i) { for(int j = 0; j &lt; LENGTH;++j) { flags[i][j] = NO_SNAKE; } } for(int i = 0; i != snake_len;++i) { MakePartSnake(LENGTH / 2 + 2 - i,LENGTH / 2,HAS_SNAKE,(snake + i)); }///初始化蛇 MakeFood(food);///产生food}void MakePartSnake(int x,int y,int flag,GRID * snake){ snake-&gt;x = x; snake-&gt;y = y; snake-&gt;flag = flag;}//控制蛇的移动void MoveSnake(HWND hwnd){ Manager(); //把蛇的尾部去除（表现为蛇移动一格） flags[(snake + snake_len - 1)-&gt;x][(snake + snake_len - 1)-&gt;y] = NO_SNAKE; for(int i = snake_len - 1; i &gt; 0;--i) { (snake+i)-&gt;x = (snake + i -1)-&gt;x; (snake+i)-&gt;y = (snake + i -1)-&gt;y; } if(direct == VK_LEFT) { snake-&gt;x -= 1; } if(direct == VK_RIGHT) { snake-&gt;x += 1; } if(direct == VK_UP) { snake-&gt;y -= 1; } if(direct == VK_DOWN) { snake-&gt;y += 1; } InvalidateRect(hwnd,NULL,FALSE); Sleep(200);}//通过随机生成foodvoid MakeFood(GRID *food){ srand((unsigned) time(NULL)); food-&gt;x = rand() % LENGTH; food-&gt;y = rand() % LENGTH; food-&gt;flag = HAS_SNAKE; flags[food-&gt;x][food-&gt;y] = food-&gt;flag;}//游戏规则的映射及内存的处理void Manager(){ if(snake_len &gt;= MAX_LENGTH - 2) { MAX_LENGTH += STEP; snake = (GRID *)realloc(snake,MAX_LENGTH * sizeof(GRID)); }//若蛇的长度数组snake将超过所分配的内存就再次扩充分配 if(snake-&gt;x &lt; 0 || snake-&gt;x &gt;= LENGTH || snake-&gt;y &lt; 0 || snake-&gt;y &gt;= LENGTH) { MessageBox(NULL,TEXT(\"Game Over!!\"),szAppName,0); initializer(); return; }///判断蛇是否碰到边界 for(int i = 4;i &lt; snake_len;++i) { if(snake-&gt;x == (snake + i)-&gt;x &amp;&amp; snake-&gt;y == (snake + i)-&gt;y) { MessageBox(NULL,TEXT(\"Game Over!!\"),szAppName,0); initializer(); return; } }////判断蛇是否碰到自身 if(food-&gt;x == snake-&gt;x &amp;&amp; food-&gt;y == snake-&gt;y) { MakePartSnake( (snake + snake_len - 1)-&gt;x ,(snake + snake_len - 1)-&gt;y ,HAS_SNAKE ,snake + snake_len ); ++snake_len; MakeFood(food); }///判断蛇是否吃到food}代码在VS2010下编译运行(我使用的开发环境，VS其它版本也可以)，可见游戏界面如下：&ensp;以上代码未考虑通关情况，也就是如果水平够高蛇会把格子占满，然后Game over。注: 若在编译时报错：1error LNK2019: 无法解析的外部符号 _main，该符号在函数 ___tmainCRTStart 可按以下方法解决： 右键点击–&gt;项目，选择–&gt;属性，属性页 窗口弹出； 接着，点击连接器-&gt;系统，在右侧会看到“子系统”选项，将选项改为/subsystem:windows. 最后附上Github项目地址：gluttonysnake 本文永久链接： http://doornote.net/2016/07/14/win32-gluttony-snake/ ；欢迎转载。","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://doornote.net/categories/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://doornote.net/tags/C-C/"},{"name":"Win32Api","slug":"Win32Api","permalink":"http://doornote.net/tags/Win32Api/"},{"name":"Windows程序设计","slug":"Windows程序设计","permalink":"http://doornote.net/tags/Windows程序设计/"}]}]}